<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2048 Python Web</title>
    <style>
        body { font-family: Arial, sans-serif; background: #faf8ef; color: #776e65; }
        #board { display: grid; grid-template-columns: repeat(4, 80px); grid-gap: 8px; margin: 30px auto; width: 352px; }
        .tile { width: 80px; height: 80px; background: #cdc1b4; display: flex; align-items: center; justify-content: center; font-size: 2em; font-weight: bold; border-radius: 4px; }
        .tile-0 { background: #cdc1b4; color: #cdc1b4; }
        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #ede0c8; color: #776e65; }
        .tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile-16 { background: #f59563; color: #f9f6f2; }
        .tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile-64 { background: #f65e3b; color: #f9f6f2; }
        .tile-128 { background: #edcf72; color: #f9f6f2; }
        .tile-256 { background: #edcc61; color: #f9f6f2; }
        .tile-512 { background: #edc850; color: #f9f6f2; }
        .tile-1024 { background: #edc53f; color: #f9f6f2; }
        .tile-2048 { background: #edc22e; color: #f9f6f2; }
        #controls { text-align: center; margin: 20px; }
        button { margin: 0 5px; padding: 10px 20px; font-size: 1em; }
        #analysis { margin: 20px auto; width: 352px; }
        #log { font-size: 0.9em; color: #888; }
    </style>
</head>
<body>
    <h1 style="text-align:center;">2048 Python Web</h1>
    <div id="controls">
        <button id="btn-play" onclick="setMode('play')">Play</button>
        <button id="btn-heuristic" onclick="setMode('heuristic')">Emulate Heuristic</button>
        <button id="btn-analysis" onclick="setMode('analysis')">Run Analysis</button>
        <select id="heuristicSelect" onchange="updateDescription()">
            <option value="monotonicity">Monotonicity</option>
            <option value="corner">Corner</option>
            <option value="center">Center</option>
            <option value="expectimax">Expectimax</option>
            <option value="opportunistic">Opportunistic</option>
            <option value="mlsim">ML Sim</option>
        </select>
        <label style="margin-left:10px;"><input type="checkbox" id="twophase" onchange="updateDescription()"> Two-Phase</label>
        <button id="btn-reset" onclick="resetGame()">Reset</button>
        <button id="btn-csv" onclick="exportResults('csv')">Export CSV</button>
        <button id="btn-html" onclick="exportResults('html')">Export HTML</button>
    </div>
    <div style="display: flex; justify-content: center; align-items: flex-start;">
        <div style="min-width: 400px;">
            <div id="board"></div>
            <div id="analysis"></div>
            <div id="log"></div>
        </div>
        <div id="sidepane" style="margin-left: 32px; width: 340px; background: #f7f7f7; border-radius: 8px; box-shadow: 0 2px 8px #ccc; min-height: 400px;">
            <div style="display: flex; border-bottom: 1px solid #ddd;">
                <button id="tab-desc" onclick="showTab('desc')" style="flex:1; padding:10px; border:none; background:#eee; font-weight:bold; transition: font-weight 0.2s;">Description</button>
                <button id="tab-stats" onclick="showTab('stats')" style="flex:1; padding:10px; border:none; background:#f7f7f7; font-weight:normal; transition: font-weight 0.2s;">Statistics</button>
            </div>
            <div id="tab-content-desc" style="padding: 16px;">
                <b>Mode:</b> <span id="desc-mode">Play</span><br><br>
                <b>Heuristic:</b> <span id="desc-heuristic">N/A</span><br><br>
                <div id="desc-details">Use arrow keys or WASD to play manually. Select a mode above.</div>
            </div>
            <div id="tab-content-stats" style="display:none; padding: 16px;">
                <div id="stats-content">No statistics yet.</div>
            </div>
        </div>
    </div>
    
    <script>
        // --- Minimal 2048 logic in JS for browser play ---
        let board, score, mode = 'play', interval = null;
        
        function emptyBoard() {
            board = Array.from({length:4},()=>Array(4).fill(0));
            score = 0;
            addTile(); addTile();
        }
        
        function addTile() {
            let empty = [];
            for(let i=0;i<4;i++) for(let j=0;j<4;j++) if(board[i][j]===0) empty.push([i,j]);
            if(empty.length===0) return;
            let [i,j] = empty[Math.floor(Math.random()*empty.length)];
            board[i][j] = Math.random()<0.1?4:2;
        }
        
        function drawBoard() {
            let html = '';
            for(let i=0;i<4;i++) for(let j=0;j<4;j++) {
                let v = board[i][j];
                html += `<div class="tile tile-${v}">${v? v : ''}</div>`;
            }
            document.getElementById('board').innerHTML = html;
            document.getElementById('log').innerText = 'Score: ' + score;
        }
        
        function move(dir) {
            let moved = false;
            let old = board.map(r=>r.slice());
            if(dir==='left'||dir==='right') {
                for(let n=0;n<4;n++) {
                    let arr = board[n].slice();
                    if(dir==='right') arr = arr.reverse();
                    let filtered = arr.filter(x=>x);
                    for(let i=0;i<filtered.length-1;i++) if(filtered[i]===filtered[i+1]) { filtered[i]*=2; score+=filtered[i]; filtered[i+1]=0; }
                    filtered = filtered.filter(x=>x);
                    while(filtered.length<4) filtered.push(0);
                    if(dir==='right') filtered = filtered.reverse();
                    board[n] = filtered;
                }
            } else if(dir==='up'||dir==='down') {
                // Transpose, operate as left/right, then transpose back
                let t = [0,1,2,3].map(i=>[board[0][i],board[1][i],board[2][i],board[3][i]]);
                for(let n=0;n<4;n++) {
                    let arr = t[n].slice();
                    if(dir==='down') arr = arr.reverse();
                    let filtered = arr.filter(x=>x);
                    for(let i=0;i<filtered.length-1;i++) if(filtered[i]===filtered[i+1]) { filtered[i]*=2; score+=filtered[i]; filtered[i+1]=0; }
                    filtered = filtered.filter(x=>x);
                    while(filtered.length<4) filtered.push(0);
                    if(dir==='down') filtered = filtered.reverse();
                    t[n] = filtered;
                }
                // Transpose back
                for(let i=0;i<4;i++) for(let j=0;j<4;j++) board[i][j]=t[j][i];
            }
            moved = JSON.stringify(old)!==JSON.stringify(board);
            if(moved) addTile();
            drawBoard();
            if(isGameOver()) document.getElementById('log').innerText += ' | Game Over!';
            return moved;
        }
        
        function isGameOver() {
            for(let i=0;i<4;i++) for(let j=0;j<4;j++) if(board[i][j]===0) return false;
            for(let i=0;i<4;i++) for(let j=0;j<3;j++) if(board[i][j]===board[i][j+1]) return false;
            for(let j=0;j<4;j++) for(let i=0;i<3;i++) if(board[i][j]===board[i+1][j]) return false;
            return true;
        }
        
        // Fix: Only attach one keydown event, and always draw board after mode change
        let keyHandler = function(e) {
            if(mode!=='play') return;
            let key = e.key.toLowerCase();
            if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(key)) {
                e.preventDefault();
                if(key==='arrowup'||key==='w') move('up');
                if(key==='arrowdown'||key==='s') move('down');
                if(key==='arrowleft'||key==='a') move('left');
                if(key==='arrowright'||key==='d') move('right');
            }
        };
        window.removeEventListener('keydown', keyHandler); // Remove if already attached
        window.addEventListener('keydown', keyHandler);
        
        // --- Tab switching with highlight ---
        function showTab(tab) {
            document.getElementById('tab-content-desc').style.display = (tab==='desc') ? '' : 'none';
            document.getElementById('tab-content-stats').style.display = (tab==='stats') ? '' : 'none';
            document.getElementById('tab-desc').style.background = (tab==='desc') ? '#eee' : '#f7f7f7';
            document.getElementById('tab-stats').style.background = (tab==='stats') ? '#eee' : '#f7f7f7';
            document.getElementById('tab-desc').style.fontWeight = (tab==='desc') ? 'bold' : 'normal';
            document.getElementById('tab-stats').style.fontWeight = (tab==='stats') ? 'bold' : 'normal';
        }
        
        // --- Heuristic implementations ---
        function evaluateMonotonicity(board) {
            let score = 0;
            // Check rows for monotonicity
            for(let i=0; i<4; i++) {
                let increasing = true, decreasing = true;
                for(let j=0; j<3; j++) {
                    if(board[i][j] > board[i][j+1]) increasing = false;
                    if(board[i][j] < board[i][j+1]) decreasing = false;
                }
                if(increasing || decreasing) score += 100;
            }
            // Check columns for monotonicity
            for(let j=0; j<4; j++) {
                let increasing = true, decreasing = true;
                for(let i=0; i<3; i++) {
                    if(board[i][j] > board[i+1][j]) increasing = false;
                    if(board[i][j] < board[i+1][j]) decreasing = false;
                }
                if(increasing || decreasing) score += 100;
            }
            return score;
        }
        
        function evaluateCorner(board) {
            let maxTile = Math.max(...board.flat());
            let corners = [board[0][0], board[0][3], board[3][0], board[3][3]];
            return corners.includes(maxTile) ? 1000 : 0;
        }
        
        function evaluateCenter(board) {
            let centerTiles = [board[1][1], board[1][2], board[2][1], board[2][2]];
            return centerTiles.reduce((sum, tile) => sum + tile, 0);
        }
        
        function evaluateExpectimax(board, depth = 2) {
            if(depth === 0 || isGameOver()) return evaluateBoard(board);
            
            let moves = ['up', 'down', 'left', 'right'];
            let bestScore = -Infinity;
            
            for(let moveDir of moves) {
                let tempBoard = board.map(row => [...row]);
                let tempScore = score;
                if(simulateMove(tempBoard, moveDir)) {
                    let expectedScore = 0;
                    let emptyCount = 0;
                    for(let i=0; i<4; i++) {
                        for(let j=0; j<4; j++) {
                            if(tempBoard[i][j] === 0) {
                                emptyCount++;
                                // Try placing 2
                                tempBoard[i][j] = 2;
                                expectedScore += 0.9 * evaluateExpectimax(tempBoard, depth-1);
                                // Try placing 4
                                tempBoard[i][j] = 4;
                                expectedScore += 0.1 * evaluateExpectimax(tempBoard, depth-1);
                                tempBoard[i][j] = 0;
                            }
                        }
                    }
                    if(emptyCount > 0) {
                        expectedScore /= emptyCount;
                        bestScore = Math.max(bestScore, expectedScore);
                    }
                }
            }
            return bestScore;
        }
        
        function evaluateOpportunistic(board) {
            let score = 0;
            // Count potential merges
            for(let i=0; i<4; i++) {
                for(let j=0; j<3; j++) {
                    if(board[i][j] === board[i][j+1] && board[i][j] > 0) score += board[i][j];
                }
            }
            for(let j=0; j<4; j++) {
                for(let i=0; i<3; i++) {
                    if(board[i][j] === board[i+1][j] && board[i][j] > 0) score += board[i][j];
                }
            }
            return score;
        }
        
        function evaluateMLSim(board) {
            // Weighted combination of features
            let empty = board.flat().filter(x => x === 0).length;
            let maxTile = Math.max(...board.flat());
            let smoothness = 0;
            for(let i=0; i<4; i++) {
                for(let j=0; j<3; j++) {
                    if(board[i][j] !== 0 && board[i][j+1] !== 0) {
                        smoothness -= Math.abs(Math.log2(board[i][j]) - Math.log2(board[i][j+1]));
                    }
                }
            }
            for(let j=0; j<4; j++) {
                for(let i=0; i<3; i++) {
                    if(board[i][j] !== 0 && board[i+1][j] !== 0) {
                        smoothness -= Math.abs(Math.log2(board[i][j]) - Math.log2(board[i+1][j]));
                    }
                }
            }
            return empty * 100 + maxTile * 10 + smoothness * 50 + evaluateMonotonicity(board);
        }
        
        function evaluateBoard(board) {
            return board.flat().reduce((sum, tile) => sum + tile, 0);
        }
        
        function simulateMove(board, dir) {
            let moved = false;
            let old = board.map(r=>r.slice());
            if(dir==='left'||dir==='right') {
                for(let n=0;n<4;n++) {
                    let arr = board[n].slice();
                    if(dir==='right') arr = arr.reverse();
                    let filtered = arr.filter(x=>x);
                    for(let i=0;i<filtered.length-1;i++) if(filtered[i]===filtered[i+1]) { filtered[i]*=2; filtered[i+1]=0; }
                    filtered = filtered.filter(x=>x);
                    while(filtered.length<4) filtered.push(0);
                    if(dir==='right') filtered = filtered.reverse();
                    board[n] = filtered;
                }
            } else if(dir==='up'||dir==='down') {
                let t = [0,1,2,3].map(i=>[board[0][i],board[1][i],board[2][i],board[3][i]]);
                for(let n=0;n<4;n++) {
                    let arr = t[n].slice();
                    if(dir==='down') arr = arr.reverse();
                    let filtered = arr.filter(x=>x);
                    for(let i=0;i<filtered.length-1;i++) if(filtered[i]===filtered[i+1]) { filtered[i]*=2; filtered[i+1]=0; }
                    filtered = filtered.filter(x=>x);
                    while(filtered.length<4) filtered.push(0);
                    if(dir==='down') filtered = filtered.reverse();
                    t[n] = filtered;
                }
                for(let i=0;i<4;i++) for(let j=0;j<4;j++) board[i][j]=t[j][i];
            }
            return JSON.stringify(old)!==JSON.stringify(board);
        }
        
        function pickHeuristicMove(heuristic) {
            let moves = ['up', 'down', 'left', 'right'];
            let bestMove = null;
            let bestScore = -Infinity;
            
            for(let moveDir of moves) {
                let tempBoard = board.map(row => [...row]);
                if(simulateMove(tempBoard, moveDir)) {
                    let score = 0;
                    switch(heuristic) {
                        case 'monotonicity': score = evaluateMonotonicity(tempBoard); break;
                        case 'corner': score = evaluateCorner(tempBoard); break;
                        case 'center': score = evaluateCenter(tempBoard); break;
                        case 'expectimax': score = evaluateExpectimax(tempBoard); break;
                        case 'opportunistic': score = evaluateOpportunistic(tempBoard); break;
                        default: score = evaluateBoard(tempBoard);
                    }
                    if(score > bestScore) {
                        bestScore = score;
                        bestMove = moveDir;
                    }
                }
            }
            return bestMove;
        }
        
        function pickMLSimMove() {
            let moves = ['up', 'down', 'left', 'right'];
            let bestMove = null;
            let bestScore = -Infinity;
            
            for(let moveDir of moves) {
                let tempBoard = board.map(row => [...row]);
                if(simulateMove(tempBoard, moveDir)) {
                    let score = evaluateMLSim(tempBoard);
                    if(score > bestScore) {
                        bestScore = score;
                        bestMove = moveDir;
                    }
                }
            }
            return bestMove;
        }
        
        function pickTwoPhaseMove(heuristic) {
            // First try monotonicity, if no good move found, use selected heuristic
            let move = pickHeuristicMove('monotonicity');
            if(!move) move = pickHeuristicMove(heuristic);
            return move;
        }
        
        function moveBoard(dir) {
            return move(dir);
        }
        
        function resetGame() {
            emptyBoard();
            drawBoard();
            clearInterval(interval);
            document.getElementById('analysis').innerHTML = '';
        }
        
        // --- Heuristic emulation mode ---
        function startHeuristicEmulation() {
            clearInterval(interval);
            interval = setInterval(()=>{
                if(mode!=='heuristic') { clearInterval(interval); return; }
                let heur = document.getElementById('heuristicSelect').value;
                let twophase = document.getElementById('twophase').checked;
                let move;
                if(heur==="mlsim") move = pickMLSimMove();
                else if(twophase) move = pickTwoPhaseMove(heur);
                else move = pickHeuristicMove(heur);
                if(move) moveBoard(move);
                drawBoard();
                if(isGameOver()) {
                    clearInterval(interval);
                    document.getElementById('log').innerText += ' | Game Over!';
                }
            }, 300);
        }
        
        // --- Analysis mode ---
        function runAnalysis() {
            let results = [];
            let runs = 20;
            let heur = document.getElementById('heuristicSelect').value;
            let twophase = document.getElementById('twophase').checked;
            let allStats = [];
            let runIdx = 0;
            let paramSummary = `<div style='margin-bottom:8px;'><b>Parameters:</b> Heuristic: <b>${heur}</b> | Two-Phase: <b>${twophase?"On":"Off"}</b></div>`;
            setControlsDisabled(true);
            
            function updateProgressBar() {
                let percent = Math.floor(100 * runIdx / runs);
                let bar = `<div style='width:100%;background:#eee;height:18px;border-radius:8px;overflow:hidden;margin-bottom:8px;'><div id='progress-inner' style='width:${percent}%;background:#f2b179;height:100%;transition:width 0.2s;'></div></div>`;
                return bar;
            }
            
            function doRun() {
                emptyBoard();
                drawBoard(); // Ensure board updates for each run
                let steps = 0;
                function doStep() {
                    let move;
                    if(heur==="mlsim") move = pickMLSimMove();
                    else if(twophase) move = pickTwoPhaseMove(heur);
                    else move = pickHeuristicMove(heur);
                    if(move && !isGameOver() && steps<1000) {
                        moveBoard(move);
                        drawBoard(); // Ensure board updates for each step
                        steps++;
                        setTimeout(doStep, 0);
                    } else {
                        let maxTile = Math.max(...board.flat());
                        allStats.push({maxTile, score});
                        results.push(maxTile);
                        runIdx++;
                        document.getElementById('analysis').innerHTML = paramSummary + updateProgressBar() + `<i>Running analysis... (${runIdx}/${runs})</i>`;
                        if(runIdx < runs) {
                            setTimeout(doRun, 0);
                        } else {
                            let avg = results.reduce((a,b)=>a+b,0)/results.length;
                            let html = paramSummary + `<b>Analysis for ${heur}${twophase?" (Two-Phase)":""}:</b><br>Runs: ${runs}<br>Average max tile: ${avg.toFixed(2)}<br>Distribution: <br>`;
                            let dist = {};
                            for(let v of results) dist[v] = (dist[v]||0)+1;
                            for(let k of Object.keys(dist).sort((a,b)=>a-b)) html += `${k}: ${dist[k]}<br>`;
                            html += `<canvas id='distChart' width='300' height='120'></canvas>`;
                            document.getElementById('analysis').innerHTML = html;
                            updateStats(html);
                            drawDistChart(dist);
                            window._lastResults = {heur, twophase, runs, results, allStats, dist, avg};
                            drawBoard();
                            setControlsDisabled(false);
                        }
                    }
                }
                setTimeout(doStep, 0); // Schedule step to allow UI update
            }
            document.getElementById('analysis').innerHTML = paramSummary + updateProgressBar() + '<i>Running analysis...</i>';
            runIdx = 0;
            setTimeout(doRun, 0); // Schedule first run to allow UI update
        }
        
        // --- Chart drawing ---
        function drawDistChart(dist) {
            setTimeout(() => {
                let canvas = document.getElementById('distChart');
                if(!canvas) return;
                let ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 300, 120);
                
                let values = Object.keys(dist).map(Number).sort((a,b)=>a-b);
                let maxCount = Math.max(...Object.values(dist));
                let barWidth = 280 / values.length;
                
                values.forEach((val, i) => {
                    let height = (dist[val] / maxCount) * 80;
                    ctx.fillStyle = '#f2b179';
                    ctx.fillRect(10 + i * barWidth, 100 - height, barWidth - 2, height);
                    ctx.fillStyle = '#776e65';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(val, 10 + i * barWidth + barWidth/2, 115);
                });
            }, 100);
        }
        
        // --- Mode switching ---
        function setMode(m) {
            mode = m;
            clearInterval(interval);
            document.getElementById('analysis').innerHTML = '';
            if(mode==='heuristic') {
                startHeuristicEmulation();
            }
            if(mode==='analysis') {
                runAnalysis();
            }
            drawBoard();
            updateDescription();
            if(mode!=='analysis') updateStats('No statistics yet.');
        }
        
        // --- Update description pane ---
        function updateDescription() {
            let modeMap = {play:'Manual Play', heuristic:'Heuristic Emulation', analysis:'Analysis'};
            let heurMap = {
                monotonicity: 'Monotonicity: Favors boards where rows/columns are strictly increasing or decreasing.',
                corner: 'Corner: Tries to keep the largest tile in a corner.',
                center: 'Center: Favors moves toward the center.',
                expectimax: 'Expectimax: Looks ahead using expected value.',
                opportunistic: 'Opportunistic: Combines tiles whenever possible.',
                mlsim: 'ML Sim: Weighted feature-based move selection.'
            };
            let twophase = document.getElementById('twophase').checked;
            let heur = document.getElementById('heuristicSelect').value;
            let heurDesc = (twophase? 'Two-Phase '+heur : heur);
            document.getElementById('desc-mode').innerText = modeMap[mode] || mode;
            document.getElementById('desc-heuristic').innerText = (mode==='heuristic'||mode==='analysis') ? heurDesc : 'N/A';
            document.getElementById('desc-details').innerText = (mode==='play') ?
                'Use arrow keys or WASD to play manually.' :
                (twophase? 'Two-phase: monotonicity, then selected heuristic.' : (heurMap[heur] || ''));
        }
        
        // --- Statistics ---
        function updateStats(content) {
            document.getElementById('stats-content').innerHTML = content;
        }
        
        // --- Export functions ---
        function exportResults(format) {
            if(!window._lastResults) {
                alert('No analysis results to export. Run an analysis first.');
                return;
            }
            
            let {heur, twophase, runs, results, allStats, dist, avg} = window._lastResults;
            
            if(format === 'csv') {
                let csv = 'Heuristic,TwoPhase,Run,MaxTile,Score\n';
                allStats.forEach((stat, i) => {
                    csv += `${heur},${twophase},${i+1},${stat.maxTile},${stat.score}\n`;
                });
                downloadFile(csv, `2048_analysis_${heur}_${twophase?'twophase_':''}${Date.now()}.csv`, 'text/csv');
            } else if(format === 'html') {
                let html = `<!DOCTYPE html><html><head><title>2048 Analysis Results</title></head><body>
                    <h1>2048 Analysis Results</h1>
                    <p><b>Heuristic:</b> ${heur}</p>
                    <p><b>Two-Phase:</b> ${twophase}</p>
                    <p><b>Runs:</b> ${runs}</p>
                    <p><b>Average Max Tile:</b> ${avg.toFixed(2)}</p>
                    <h2>Distribution:</h2>
                    <ul>`;
                for(let k of Object.keys(dist).sort((a,b)=>a-b)) {
                    html += `<li>${k}: ${dist[k]}</li>`;
                }
                html += `</ul></body></html>`;
                downloadFile(html, `2048_analysis_${heur}_${twophase?'twophase_':''}${Date.now()}.html`, 'text/html');
            }
        }
        
        function downloadFile(content, filename, contentType) {
            let blob = new Blob([content], {type: contentType});
            let url = window.URL.createObjectURL(blob);
            let a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
        
        // --- Init ---
        function updateControls() {
            // For future: enable/disable controls if needed
        }
        emptyBoard(); drawBoard();
        document.getElementById('heuristicSelect').addEventListener('change', updateDescription);
        document.getElementById('twophase').addEventListener('change', updateDescription);
        // Initial tab and desc
        showTab('desc');
        updateDescription();
        
        function setControlsDisabled(disabled) {
            document.getElementById('btn-play').disabled = disabled;
            document.getElementById('btn-heuristic').disabled = disabled;
            document.getElementById('btn-analysis').disabled = disabled;
            document.getElementById('heuristicSelect').disabled = disabled;
            document.getElementById('twophase').disabled = disabled;
            document.getElementById('btn-reset').disabled = disabled;
            document.getElementById('btn-csv').disabled = disabled;
            document.getElementById('btn-html').disabled = disabled;
        }
    </script>
</body>
</html>
